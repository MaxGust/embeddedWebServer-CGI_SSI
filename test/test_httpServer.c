#include "test.h"

//copy of index contents in new file for test
static unsigned char index1_html[] = {
    0x3c, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0x0a, 0x20, 0x20, 0x3c, 0x62, 0x6f,
    0x64, 0x79, 0x3e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x3c, 0x48, 0x31, 0x3e,
    0x48, 0x45, 0x4c, 0x4c, 0x4f, 0x20, 0x57, 0x4f, 0x52, 0x4c, 0x44, 0x3c,
    0x2f, 0x48, 0x31, 0x3e, 0x0a, 0x20, 0x20, 0x3c, 0x2f, 0x62, 0x6f, 0x64,
    0x79, 0x3e, 0x0a, 0x3c, 0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0x0a};
static unsigned int index1_html_len = 59;
static char *path_index1_html = "/index1.html";

static unsigned char index_long_html[] = {
    0x3c, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0x0a, 0x20, 0x20, 0x3c, 0x62, 0x6f,
    0x64, 0x79, 0x3e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x3c, 0x48, 0x31, 0x3e,
    0x48, 0x45, 0x4c, 0x4c, 0x4f, 0x20, 0x57, 0x4f, 0x52, 0x4c, 0x44, 0x3c,
    0x2f, 0x48, 0x31, 0x3e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x22, 0x4c, 0x6f,
    0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6d, 0x20, 0x64, 0x6f,
    0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74,
    0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74, 0x75,
    0x72, 0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e, 0x67,
    0x20, 0x65, 0x6c, 0x69, 0x74, 0x2c, 0x20, 0x73, 0x65, 0x64, 0x20, 0x64,
    0x6f, 0x20, 0x65, 0x69, 0x75, 0x73, 0x6d, 0x6f, 0x64, 0x20, 0x74, 0x65,
    0x6d, 0x70, 0x6f, 0x72, 0x20, 0x69, 0x6e, 0x63, 0x69, 0x64, 0x69, 0x64,
    0x75, 0x6e, 0x74, 0x20, 0x75, 0x74, 0x20, 0x6c, 0x61, 0x62, 0x6f, 0x72,
    0x65, 0x20, 0x65, 0x74, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x65, 0x20,
    0x6d, 0x61, 0x67, 0x6e, 0x61, 0x20, 0x61, 0x6c, 0x69, 0x71, 0x75, 0x61,
    0x2e, 0x20, 0x55, 0x74, 0x20, 0x65, 0x6e, 0x69, 0x6d, 0x20, 0x61, 0x64,
    0x20, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x20, 0x76, 0x65, 0x6e, 0x69, 0x61,
    0x6d, 0x2c, 0x20, 0x71, 0x75, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x73, 0x74,
    0x72, 0x75, 0x64, 0x20, 0x65, 0x78, 0x65, 0x72, 0x63, 0x69, 0x74, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x75, 0x6c, 0x6c, 0x61, 0x6d, 0x63, 0x6f,
    0x20, 0x6c, 0x61, 0x62, 0x6f, 0x72, 0x69, 0x73, 0x20, 0x6e, 0x69, 0x73,
    0x69, 0x20, 0x75, 0x74, 0x20, 0x61, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x70,
    0x20, 0x65, 0x78, 0x20, 0x65, 0x61, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
    0x64, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x71, 0x75, 0x61, 0x74,
    0x2e, 0x20, 0x44, 0x75, 0x69, 0x73, 0x20, 0x61, 0x75, 0x74, 0x65, 0x20,
    0x69, 0x72, 0x75, 0x72, 0x65, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20,
    0x69, 0x6e, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x68, 0x65, 0x6e, 0x64,
    0x65, 0x72, 0x69, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x76, 0x6f, 0x6c, 0x75,
    0x70, 0x74, 0x61, 0x74, 0x65, 0x20, 0x76, 0x65, 0x6c, 0x69, 0x74, 0x20,
    0x65, 0x73, 0x73, 0x65, 0x20, 0x63, 0x69, 0x6c, 0x6c, 0x75, 0x6d, 0x20,
    0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x65, 0x20, 0x65, 0x75, 0x20, 0x66, 0x75,
    0x67, 0x69, 0x61, 0x74, 0x20, 0x6e, 0x75, 0x6c, 0x6c, 0x61, 0x20, 0x70,
    0x61, 0x72, 0x69, 0x61, 0x74, 0x75, 0x72, 0x2e, 0x20, 0x45, 0x78, 0x63,
    0x65, 0x70, 0x74, 0x65, 0x75, 0x72, 0x20, 0x73, 0x69, 0x6e, 0x74, 0x20,
    0x6f, 0x63, 0x63, 0x61, 0x65, 0x63, 0x61, 0x74, 0x20, 0x63, 0x75, 0x70,
    0x69, 0x64, 0x61, 0x74, 0x61, 0x74, 0x20, 0x6e, 0x6f, 0x6e, 0x20, 0x70,
    0x72, 0x6f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x73, 0x75, 0x6e,
    0x74, 0x20, 0x69, 0x6e, 0x20, 0x63, 0x75, 0x6c, 0x70, 0x61, 0x20, 0x71,
    0x75, 0x69, 0x20, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x69, 0x61, 0x20, 0x64,
    0x65, 0x73, 0x65, 0x72, 0x75, 0x6e, 0x74, 0x20, 0x6d, 0x6f, 0x6c, 0x6c,
    0x69, 0x74, 0x20, 0x61, 0x6e, 0x69, 0x6d, 0x20, 0x69, 0x64, 0x20, 0x65,
    0x73, 0x74, 0x20, 0x6c, 0x61, 0x62, 0x6f, 0x72, 0x75, 0x6d, 0x2e, 0x22,
    0x0a, 0x20, 0x20, 0x20, 0x20, 0x22, 0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20,
    0x69, 0x70, 0x73, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20,
    0x73, 0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f,
    0x6e, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74, 0x75, 0x72, 0x20, 0x61, 0x64,
    0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c, 0x69,
    0x74, 0x2c, 0x20, 0x73, 0x65, 0x64, 0x20, 0x64, 0x6f, 0x20, 0x65, 0x69,
    0x75, 0x73, 0x6d, 0x6f, 0x64, 0x20, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72,
    0x20, 0x69, 0x6e, 0x63, 0x69, 0x64, 0x69, 0x64, 0x75, 0x6e, 0x74, 0x20,
    0x75, 0x74, 0x20, 0x6c, 0x61, 0x62, 0x6f, 0x72, 0x65, 0x20, 0x65, 0x74,
    0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x65, 0x20, 0x6d, 0x61, 0x67, 0x6e,
    0x61, 0x20, 0x61, 0x6c, 0x69, 0x71, 0x75, 0x61, 0x2e, 0x20, 0x55, 0x74,
    0x20, 0x65, 0x6e, 0x69, 0x6d, 0x20, 0x61, 0x64, 0x20, 0x6d, 0x69, 0x6e,
    0x69, 0x6d, 0x20, 0x76, 0x65, 0x6e, 0x69, 0x61, 0x6d, 0x2c, 0x20, 0x71,
    0x75, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x73, 0x74, 0x72, 0x75, 0x64, 0x20,
    0x65, 0x78, 0x65, 0x72, 0x63, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x20, 0x75, 0x6c, 0x6c, 0x61, 0x6d, 0x63, 0x6f, 0x20, 0x6c, 0x61, 0x62,
    0x6f, 0x72, 0x69, 0x73, 0x20, 0x6e, 0x69, 0x73, 0x69, 0x20, 0x75, 0x74,
    0x20, 0x61, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x70, 0x20, 0x65, 0x78, 0x20,
    0x65, 0x61, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x64, 0x6f, 0x20, 0x63,
    0x6f, 0x6e, 0x73, 0x65, 0x71, 0x75, 0x61, 0x74, 0x2e, 0x20, 0x44, 0x75,
    0x69, 0x73, 0x20, 0x61, 0x75, 0x74, 0x65, 0x20, 0x69, 0x72, 0x75, 0x72,
    0x65, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x69, 0x6e, 0x20, 0x72,
    0x65, 0x70, 0x72, 0x65, 0x68, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x69, 0x74,
    0x20, 0x69, 0x6e, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x70, 0x74, 0x61, 0x74,
    0x65, 0x20, 0x76, 0x65, 0x6c, 0x69, 0x74, 0x20, 0x65, 0x73, 0x73, 0x65,
    0x20, 0x63, 0x69, 0x6c, 0x6c, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f,
    0x72, 0x65, 0x20, 0x65, 0x75, 0x20, 0x66, 0x75, 0x67, 0x69, 0x61, 0x74,
    0x20, 0x6e, 0x75, 0x6c, 0x6c, 0x61, 0x20, 0x70, 0x61, 0x72, 0x69, 0x61,
    0x74, 0x75, 0x72, 0x2e, 0x20, 0x45, 0x78, 0x63, 0x65, 0x70, 0x74, 0x65,
    0x75, 0x72, 0x20, 0x73, 0x69, 0x6e, 0x74, 0x20, 0x6f, 0x63, 0x63, 0x61,
    0x65, 0x63, 0x61, 0x74, 0x20, 0x63, 0x75, 0x70, 0x69, 0x64, 0x61, 0x74,
    0x61, 0x74, 0x20, 0x6e, 0x6f, 0x6e, 0x20, 0x70, 0x72, 0x6f, 0x69, 0x64,
    0x65, 0x6e, 0x74, 0x2c, 0x20, 0x73, 0x75, 0x6e, 0x74, 0x20, 0x69, 0x6e,
    0x20, 0x63, 0x75, 0x6c, 0x70, 0x61, 0x20, 0x71, 0x75, 0x69, 0x20, 0x6f,
    0x66, 0x66, 0x69, 0x63, 0x69, 0x61, 0x20, 0x64, 0x65, 0x73, 0x65, 0x72,
    0x75, 0x6e, 0x74, 0x20, 0x6d, 0x6f, 0x6c, 0x6c, 0x69, 0x74, 0x20, 0x61,
    0x6e, 0x69, 0x6d, 0x20, 0x69, 0x64, 0x20, 0x65, 0x73, 0x74, 0x20, 0x6c,
    0x61, 0x62, 0x6f, 0x72, 0x75, 0x6d, 0x2e, 0x22, 0x0a, 0x20, 0x20, 0x20,
    0x20, 0x22, 0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75,
    0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74, 0x20,
    0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63,
    0x74, 0x65, 0x74, 0x75, 0x72, 0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73,
    0x63, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c, 0x69, 0x74, 0x2c, 0x20, 0x73,
    0x65, 0x64, 0x20, 0x64, 0x6f, 0x20, 0x65, 0x69, 0x75, 0x73, 0x6d, 0x6f,
    0x64, 0x20, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x20, 0x69, 0x6e, 0x63,
    0x69, 0x64, 0x69, 0x64, 0x75, 0x6e, 0x74, 0x20, 0x75, 0x74, 0x20, 0x6c,
    0x61, 0x62, 0x6f, 0x72, 0x65, 0x20, 0x65, 0x74, 0x20, 0x64, 0x6f, 0x6c,
    0x6f, 0x72, 0x65, 0x20, 0x6d, 0x61, 0x67, 0x6e, 0x61, 0x20, 0x61, 0x6c,
    0x69, 0x71, 0x75, 0x61, 0x2e, 0x20, 0x55, 0x74, 0x20, 0x65, 0x6e, 0x69,
    0x6d, 0x20, 0x61, 0x64, 0x20, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x20, 0x76,
    0x65, 0x6e, 0x69, 0x61, 0x6d, 0x2c, 0x20, 0x71, 0x75, 0x69, 0x73, 0x20,
    0x6e, 0x6f, 0x73, 0x74, 0x72, 0x75, 0x64, 0x20, 0x65, 0x78, 0x65, 0x72,
    0x63, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x75, 0x6c, 0x6c,
    0x61, 0x6d, 0x63, 0x6f, 0x20, 0x6c, 0x61, 0x62, 0x6f, 0x72, 0x69, 0x73,
    0x20, 0x6e, 0x69, 0x73, 0x69, 0x20, 0x75, 0x74, 0x20, 0x61, 0x6c, 0x69,
    0x71, 0x75, 0x69, 0x70, 0x20, 0x65, 0x78, 0x20, 0x65, 0x61, 0x20, 0x63,
    0x6f, 0x6d, 0x6d, 0x6f, 0x64, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65,
    0x71, 0x75, 0x61, 0x74, 0x2e, 0x20, 0x44, 0x75, 0x69, 0x73, 0x20, 0x61,
    0x75, 0x74, 0x65, 0x20, 0x69, 0x72, 0x75, 0x72, 0x65, 0x20, 0x64, 0x6f,
    0x6c, 0x6f, 0x72, 0x20, 0x69, 0x6e, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65,
    0x68, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x69, 0x74, 0x20, 0x69, 0x6e, 0x20,
    0x76, 0x6f, 0x6c, 0x75, 0x70, 0x74, 0x61, 0x74, 0x65, 0x20, 0x76, 0x65,
    0x6c, 0x69, 0x74, 0x20, 0x65, 0x73, 0x73, 0x65, 0x20, 0x63, 0x69, 0x6c,
    0x6c, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x65, 0x20, 0x65,
    0x75, 0x20, 0x66, 0x75, 0x67, 0x69, 0x61, 0x74, 0x20, 0x6e, 0x75, 0x6c,
    0x6c, 0x61, 0x20, 0x70, 0x61, 0x72, 0x69, 0x61, 0x74, 0x75, 0x72, 0x2e,
    0x20, 0x45, 0x78, 0x63, 0x65, 0x70, 0x74, 0x65, 0x75, 0x72, 0x20, 0x73,
    0x69, 0x6e, 0x74, 0x20, 0x6f, 0x63, 0x63, 0x61, 0x65, 0x63, 0x61, 0x74,
    0x20, 0x63, 0x75, 0x70, 0x69, 0x64, 0x61, 0x74, 0x61, 0x74, 0x20, 0x6e,
    0x6f, 0x6e, 0x20, 0x70, 0x72, 0x6f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x2c,
    0x20, 0x73, 0x75, 0x6e, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x63, 0x75, 0x6c,
    0x70, 0x61, 0x20, 0x71, 0x75, 0x69, 0x20, 0x6f, 0x66, 0x66, 0x69, 0x63,
    0x69, 0x61, 0x20, 0x64, 0x65, 0x73, 0x65, 0x72, 0x75, 0x6e, 0x74, 0x20,
    0x6d, 0x6f, 0x6c, 0x6c, 0x69, 0x74, 0x20, 0x61, 0x6e, 0x69, 0x6d, 0x20,
    0x69, 0x64, 0x20, 0x65, 0x73, 0x74, 0x20, 0x6c, 0x61, 0x62, 0x6f, 0x72,
    0x75, 0x6d, 0x2e, 0x22, 0x0a, 0x20, 0x20, 0x3c, 0x2f, 0x62, 0x6f, 0x64,
    0x79, 0x3e, 0x0a, 0x3c, 0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0x0a};
static unsigned int index_long_html_len = 1415;
static char *path_index_long_html = "/index_long.html";

unsigned char SSI_html[] = {
  0x3c, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0x0a, 0x20, 0x20, 0x3c, 0x62, 0x6f,
  0x64, 0x79, 0x3e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x3c, 0x48, 0x31, 0x3e,
  0x48, 0x45, 0x4c, 0x4c, 0x4f, 0x20, 0x57, 0x4f, 0x52, 0x4c, 0x44, 0x3c,
  0x2f, 0x48, 0x31, 0x3e, 0x3c, 0x70, 0x2f, 0x3e, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x54, 0x69, 0x6d, 0x65, 0x72, 0x20, 0x56, 0x61, 0x6c, 0x75, 0x65,
  0x20, 0x69, 0x73, 0x20, 0x3a, 0x20, 0x3c, 0x21, 0x2d, 0x2d, 0x23, 0x74,
  0x69, 0x6d, 0x65, 0x72, 0x56, 0x61, 0x6c, 0x23, 0x2d, 0x2d, 0x3e, 0x20,
  0x3c, 0x70, 0x2f, 0x3e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x54, 0x69, 0x6d,
  0x65, 0x72, 0x20, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20,
  0x3a, 0x20, 0x3c, 0x21, 0x2d, 0x2d, 0x23, 0x74, 0x69, 0x6d, 0x65, 0x72,
  0x64, 0x61, 0x6c, 0x23, 0x2d, 0x2d, 0x3e, 0x20, 0x3c, 0x70, 0x2f, 0x3e,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x72, 0x20, 0x56,
  0x61, 0x6c, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x3a, 0x20, 0x3c, 0x21,
  0x2d, 0x2d, 0x23, 0x74, 0x69, 0x6d, 0x65, 0x72, 0x56, 0x61, 0x6c, 0x23,
  0x2d, 0x2d, 0x3e, 0x20, 0x3c, 0x70, 0x2f, 0x3e, 0x0a, 0x20, 0x20, 0x20,
  0x20, 0x54, 0x69, 0x6d, 0x65, 0x72, 0x20, 0x56, 0x61, 0x6c, 0x75, 0x65,
  0x20, 0x69, 0x73, 0x20, 0x3a, 0x20, 0x3c, 0x21, 0x2d, 0x2d, 0x23, 0x74,
  0x69, 0x6d, 0x65, 0x72, 0x64, 0x61, 0x6c, 0x23, 0x2d, 0x2d, 0x3e, 0x20,
  0x3c, 0x70, 0x2f, 0x3e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6b, 0x61, 0x69,
  0x73, 0x65, 0x72, 0x20, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x69, 0x73,
  0x20, 0x3a, 0x20, 0x3c, 0x21, 0x2d, 0x2d, 0x23, 0x6b, 0x61, 0x69, 0x73,
  0x65, 0x72, 0x56, 0x61, 0x6c, 0x23, 0x2d, 0x2d, 0x3e, 0x20, 0x3c, 0x70,
  0x2f, 0x3e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6b, 0x61, 0x69, 0x73, 0x65,
  0x72, 0x20, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x3a,
  0x20, 0x3c, 0x21, 0x2d, 0x2d, 0x23, 0x6b, 0x61, 0x69, 0x73, 0x65, 0x72,
  0x56, 0x61, 0x6c, 0x23, 0x2d, 0x2d, 0x3e, 0x20, 0x3c, 0x70, 0x2f, 0x3e,
  0x0a, 0x20, 0x20, 0x3c, 0x2f, 0x62, 0x6f, 0x64, 0x79, 0x3e, 0x0a, 0x3c,
  0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0x0a
};
unsigned int SSI_html_len = 331;
static char *path_SSI_ssi = "/SSI.ssi";





/*wrapper functions for type sanity. 
if this is not done casting fp to void will cause compiler warnings
*/
static void *http_localfs_fopen_w(const char *filename);
static int http_localfs_fclose_w(void *fp);
static size_t http_localfs_fread_w(void *ptr, size_t size, size_t nmemb, void *fp);
static int http_localfs_fgetc_w(void *fp);
static int http_localfs_fseek_w(void *fp, long offset, int whence);
static int http_localfs_feof_w(void *fp);

static void *http_localfs_fopen_w(const char *filename) { return (void *)http_localfs_fopen(filename); }
static int http_localfs_fclose_w(void *fp) { return http_localfs_fclose((http_localfs_filesystem_fp_t)fp); }
static size_t http_localfs_fread_w(void *ptr, size_t size, size_t nmemb, void *fp) { return http_localfs_fread(ptr, size, nmemb, (http_localfs_filesystem_fp_t)fp); }
static int http_localfs_fgetc_w(void *fp) { return http_localfs_fgetc((http_localfs_filesystem_fp_t)fp); }
static int http_localfs_fseek_w(void *fp, long offset, int whence) { return http_localfs_fseek((http_localfs_filesystem_fp_t)fp, offset, whence); }
static int http_localfs_feof_w(void *fp) { return http_localfs_feof((http_localfs_filesystem_fp_t)fp); }



int http_server_dummy_read(int socket, unsigned char *readBuffer, int readBufferLength, int timeoutMs);
int http_server_dummy_write(int socket, unsigned char *readBuffer, int readBufferLength, int timeoutMs);
void http_server_dummy_disconnect(int socket);

int http_server_dummy_read(int socket, unsigned char *readBuffer, int readBufferLength, int timeoutMs)
{
  unsigned char sock1RequestBuffer[] = "GET /ta.gs/ref_htt%20%20pmethods.html\r\ncache-control: no-cache\r\naccept-encoding: gzip, deflate\r\n\r\n";
  unsigned char sock2RequestBuffer[] = "GET /index1.html\r\ncache-control: no-cache\r\naccept-encoding: gzip, deflate\r\n\r\n";
  unsigned char sock3RequestBuffer[] = "GET /ta.gs/ref_htt%20%20pmethods.cgi\r\ncache-control: no-cache\r\naccept-encoding: gzip, deflate\r\n\r\n";
  unsigned char sock4RequestBuffer[] = "GET /cgi/test.cgi\r\ncache-control: no-cache\r\naccept-encoding: gzip, deflate\r\n\r\n";
  unsigned char sock5RequestBuffer[] = "GET /index_long.html\r\ncache-control: no-cache\r\naccept-encoding: gzip, deflate\r\n\r\n";
  unsigned char sock6RequestBuffer[] = "GET /SSI.ssi\r\ncache-control: no-cache\r\naccept-encoding: gzip, deflate\r\n\r\n";

  if ((0 > socket) || (NULL == readBuffer) || (0 == readBufferLength) || (0 > timeoutMs))
  {
    return -1;
  }
  switch (socket)
  {
  case 1: //non-existetn file
    memcpy((void *)readBuffer, (void *)&sock1RequestBuffer, sizeof(sock1RequestBuffer));
    return (int)sizeof(sock1RequestBuffer);
    break;
  case 2: //index.html
    memcpy((void *)readBuffer, (void *)&sock2RequestBuffer, sizeof(sock2RequestBuffer));
    return (int)sizeof(sock2RequestBuffer);
    break;
  case 3:
    memcpy((void *)readBuffer, (void *)&sock3RequestBuffer, sizeof(sock3RequestBuffer));
    return (int)sizeof(sock3RequestBuffer);
    break;
  case 4:
    memcpy((void *)readBuffer, (void *)&sock4RequestBuffer, sizeof(sock4RequestBuffer));
    return (int)sizeof(sock3RequestBuffer);
    break;
  case 5:
    memcpy((void *)readBuffer, (void *)&sock5RequestBuffer, sizeof(sock5RequestBuffer));
    return (int)sizeof(sock3RequestBuffer);
    break;
  case 6:
    memcpy((void *)readBuffer, (void *)&sock6RequestBuffer, sizeof(sock6RequestBuffer));
    return (int)sizeof(sock3RequestBuffer);
    break;

  default:
    return -1;
    break;
  }

  return -1;
}
int http_server_dummy_write(int socket, unsigned char *writeBuffer, int writeBufferLength, int timeoutMs)
{
  char *sock1RetString = "HTTP/1.1 404 Not Found\r\n\r\n";
  char *sock2RetHeader = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: 59\r\n\r\n";
  char *sock4RetHeader = "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: 4\r\n\r\n";
  static int headerBody = 0;
  size_t compLen;
  if ((0 > socket) || (NULL == writeBuffer) || (0 == writeBufferLength) || (0 > timeoutMs))
  {
    return -1;
  }
  switch (socket)
  {
  case 1:
    compLen = strlen(sock1RetString);
    if (0 != strncmp((char *)writeBuffer, sock1RetString, compLen))
    {
      printf(FAIL "test_http_server (HTML 404 filenot found)\r\n");
      return -1;
    }
    printf(PASS "test_http_server (HTML 404 filenot found)\r\n");
    break;
  case 2:
    if (0 == headerBody)
    { //expecting header to be written
      compLen = strlen(sock2RetHeader);
      if (0 != strncmp(sock2RetHeader, (char *)writeBuffer, compLen))
      {
        printf(FAIL "test_http_server (HTML 200 OK header test)\r\n");
        return -1;
      }
      printf(PASS "test_http_server (HTML 200 OK header test)\r\n");
      headerBody += 1; //next expect body
      return 0;
    }
    else if (1 == headerBody)
    {
      headerBody = 0; //set for next test
      if (0 != strncmp((char *)writeBuffer, (char *)index1_html, index1_html_len))
      {
        printf(FAIL "test_http_server (HTML 200 OK body test (%d,%d))\r\n", index1_html_len, writeBufferLength);
        return -1;
      }
      printf(PASS "test_http_server (HTML 200 OK body test(%d,%d))\r\n", index1_html_len, writeBufferLength);
      return 0;
    }
    break;
  case 3:
    compLen = strlen(sock1RetString);
    if (0 != strncmp((char *)writeBuffer, sock1RetString, compLen))
    {
      printf(FAIL "test_http_server (404 filenot found - cgi)\r\n");
      return -1;
    }
    printf(PASS "test_http_server (404 filenot found-cgi)\r\n");
    break;
  case 4:
    if (0 == headerBody)
    {
      headerBody = 1; //next expect body
      compLen = strlen(sock4RetHeader);
      if (0 != strncmp(sock4RetHeader, (char *)writeBuffer, compLen))
      {
        printf(FAIL "test_http_server (CGI HTML 200 OK header test)\r\n");
        return -1;
      }
      printf(PASS "test_http_server (CGI HTML 200 OK header test)\r\n");
      return 0;
    }
    else if (1 == headerBody)
    {
      headerBody = 0; //set for next test
      if (0 != strncmp((char *)writeBuffer, "0xA0", 4))
      {
        printf(FAIL "test_http_server (CGI - HTML 200 OK body test)\r\n");
        return -1;
      }
      printf(PASS "test_http_server (CGI - HTML 200 OK body test(%d,%d))\r\n", index1_html_len, writeBufferLength);
      return 0;
    }
    break;
  case 5: //large file read with chunked output
    //printf("socket write stub (sock: %d, len: %d)\r\n", socket, writeBufferLength);
    //printf("%.*s", writeBufferLength, writeBuffer);
    //TODO: assumed pass since we are yet to write full test case here.
    break;
  case 6:  //ssi replacement - small buffer
    printf("socket write stub (sock: %d, len: %d)\r\n", socket, writeBufferLength);
    printf("%.*s", writeBufferLength, writeBuffer);
  break;
  default:
    return -1;
    break;
  }
  //printf("socket write stub (sock: %d, len: %d)\r\n", socket, writeBufferLength);
  //printf("%.*s", writeBufferLength, writeBuffer);

  return -1;
}
void http_server_dummy_disconnect(int socket)
{
  if (socket <= 0)
  {
    printf(FAIL "Disconnecting socket (%d)\r\n", socket);
  }
}

char *serverTest_cgiPathFunction_ret = "0xA0";
int httpServerTest_cgiPathFunction(const char *CGIPath, char *replacerBuffer, unsigned int bufferLength);
int httpServerTest_cgiPathFunction(const char *CGIPath, char *replacerBuffer, unsigned int bufferLength)
{
  if (0 != strcmp(CGIPath, "/cgi/test.cgi"))
    return -1;
  if ((bufferLength <= 0) || NULL == replacerBuffer)
    return -1;
  strncpy(replacerBuffer, serverTest_cgiPathFunction_ret, strlen(serverTest_cgiPathFunction_ret));
  return strlen(serverTest_cgiPathFunction_ret);
}

/*test callbacks to replace SSI string timerVal*/
int server_test_timerVal_SSI_replacer_cb(const char *SSIString, char *replacerBuffer, unsigned int bufferLength);
int server_test_timerVal_SSI_replacer_cb(const char *SSIString, char *replacerBuffer, unsigned int bufferLength)
{
  if (0 != strcmp("timerVal", SSIString))
  {
    printf(FAIL "timerVal_SSI_replacer_cb (SSI string missmatch)\r\n");
    return -1;
  }
  strncpy(replacerBuffer, "200 string", bufferLength);
  replacerBuffer[bufferLength] = 0;
  return 0;
}

int server_test_kaiserVal_SSI_replacer_cb(const char *SSIString, char *replacerBuffer, unsigned int bufferLength);
int server_test_kaiserVal_SSI_replacer_cb(const char *SSIString, char *replacerBuffer, unsigned int bufferLength)
{
  if (0 != strcmp("kaiserVal", SSIString))
  {
    printf(FAIL "kaiserVal_SSI_replacer_cb (SSI string missmatch)\r\n");
    return -1;
  }
  snprintf(replacerBuffer,  bufferLength, "kaiserVal");
  return 0;
}
//http_server_test
int test_http_server(void)
{
  //deinit and init the FS
  http_file_fops_t localFSFops;
  http_localfs_deinit(); //just in case previous test left it in stale state
  http_localfs_init();
  char *serverTestCGIPath = "/cgi/test.cgi";
  //register default index file into the local file system.
  int retval = http_localfs_registerFile(path_index1_html, (char *)&index1_html, index1_html_len, 0);
  if (retval < 0)
  {
    printf(FAIL "test_http_server(registerFile failed)\r\n");
    return -1;
  }
  retval = http_localfs_registerFile(path_index_long_html, (char *)&index_long_html, index_long_html_len, 0);
  if (retval < 0)
  {
    printf(FAIL "test_http_server(register long File failed)\r\n");
    return -1;
  }
  retval = http_localfs_registerFile(path_SSI_ssi, (char *)&SSI_html, SSI_html_len, 0);
  if (retval < 0)
  {
    printf(FAIL "test_http_server(http_localfs_registerFile)\r\n");
    return -1;
  }
  //register fops. reusing fops wrapers from fs test
  http_file_init_fopsStruct(&localFSFops);
  localFSFops.fopen = http_localfs_fopen_w;
  localFSFops.fclose = http_localfs_fclose_w;
  localFSFops.fread = http_localfs_fread_w;
  localFSFops.fgetc = http_localfs_fgetc_w;
  localFSFops.fseek = http_localfs_fseek_w;
  localFSFops.feof = http_localfs_feof_w;
  http_file_register_fops(localFSFops);
  //register stub netops
  http_net_netops_t http_net_test_netops;
  http_net_init_netopsStruct(&http_net_test_netops);

  http_net_test_netops.http_net_read = http_server_dummy_read;
  http_net_test_netops.http_net_write = http_server_dummy_write;
  http_net_test_netops.http_net_disconnect = http_server_dummy_disconnect;
  http_net_netops_t *httpNetops = http_net_register_netops(http_net_test_netops);

  //socket1 test - non-existant file
  if (0 > http_server(1, httpNetops))
  {
    printf(FAIL "test_http_server(sock 1)\r\n");
    return -1;
  }
  //socket2 test - index1.html from test page
  if (0 > http_server(2, httpNetops))
  {
    printf(FAIL "test_http_server(sock 2)\r\n");
    return -1;
  }
  //socket3 test - non existant CGI page
  if (0 > http_server(3, httpNetops))
  {
    printf(FAIL "test_http_server(sock 3)\r\n");
    return -1;
  }

  //register a CGI path function
  http_CGI_pathFunction_t *cgiPathHandle2;
  cgiPathHandle2 = http_CGI_register_pathFunction(serverTestCGIPath, httpServerTest_cgiPathFunction, HTTP_contentType_plaintext);
  if (NULL == cgiPathHandle2)
  {
    printf(FAIL "test_http_server(http_CGI_register_pathFunction)");
    return -1;
  }

  //now call the server for CGI test socket
  if (0 > http_server(4, httpNetops))
  {
    printf(FAIL "test_http_server(sock 4)\r\n");
    return -1;
  }

  //now call the server for CGI test socket
  if (0 > http_server(5, httpNetops))
  {
    printf(FAIL "test_http_server(sock 5)\r\n");
    return -1;
  }

  //now register an SSI string
  http_SSI_deRegister_all();
  http_SSI_replacer_t *SSIReplacementHandle;
  SSIReplacementHandle = http_SSI_register_replacer("timerVal", server_test_timerVal_SSI_replacer_cb);
  if (NULL == SSIReplacementHandle)
  {
    printf(FAIL "test_http_server(http_SSI_register_replacer timerVal)\r\n");
    return -1;
  }
  SSIReplacementHandle = http_SSI_register_replacer("kaiserVal", server_test_kaiserVal_SSI_replacer_cb);
  if (NULL == SSIReplacementHandle)
  {
    printf(FAIL "test_http_server(http_SSI_register_replacer kaiserVal)\r\n");
    return -1;
  }
  //now call the server for SSI test socket
  if (0 > http_server(6, httpNetops))
  {
    printf(FAIL "test_http_server(sock 6)\r\n");
    return -1;
  }


  printf(PASS ">>test_http_server<<\r\n");
  return 0;
}
